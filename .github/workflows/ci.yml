name: devvesg-ci

on:
  push:
    branches:
      - dev
      - staging
      - qa
      - demo
      - prod
  pull_request:
    branches:
      - dev
  workflow_dispatch:

concurrency:
  group: "${{ github.ref }}-ci"
  cancel-in-progress: true

jobs:
  setup-env:
    name: Setup environment
    runs-on: ubuntu-20.04

    steps:
      - uses: actions/checkout@v2
        id: checkout

      - name: Translate environment
        id: translate-environment
        run: |
          deploy_env=""
          do_deploy="false"

          if [[ "${GITHUB_REF_NAME}" =~ ^(dev|staging|qa)$ ]]; then
            deploy_env="${BASH_REMATCH[0]}"
            infra_env=non_prod
            do_deploy=true
          elif [[ "${GITHUB_REF_NAME}" =~ ^(demo|prod)$ ]]; then
            deploy_env="${BASH_REMATCH[0]}"
            infra_env=production
            do_deploy=true
          fi

          if [ -z "${deploy_env}" ]; then
            # random feature/fix/chore/hotfix branch
            infra_env=non_prod
            deploy_env="dev"
          fi

          echo "::set-output name=deploy_env::${deploy_env}"
          echo "::set-output name=do_deploy::${do_deploy}"
          echo "::set-output name=infra_env::${infra_env}"

      - name: Get short SHA
        id: get-short-sha
        run: |
          sha_short=$(git rev-parse --short HEAD)
          echo "::set-output name=sha_short::${sha_short}"

    outputs:
      deploy_env: ${{ steps.translate-environment.outputs.deploy_env }}
      do_deploy: ${{ steps.translate-environment.outputs.do_deploy }}
      infra_env: ${{ steps.translate-environment.outputs.infra_env }}
      sha_short: ${{ steps.get-short-sha.outputs.sha_short }}

  test-helm:
    name: Helm lint and template
    runs-on: ubuntu-20.04

    needs:
      - setup-env

    steps:
      - uses: actions/checkout@v2
        id: checkout

      - name: Setup stage environment variables
        id: setup-stage-env-vars
        env:
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
        run: |
          echo "::set-env name=AWS_ACCESS_KEY_ID_SECRET_NAME::AWS_DEPLOY_ACCESS_KEY_ID_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_SECRET_ACCESS_KEY_SECRET_NAME::AWS_DEPLOY_SECRET_ACCESS_KEY_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_CLOUDFRONT_DISTRIBUTION_ID_NAME::AWS_CLOUDFRONT_DISTRIBUTION_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"
          echo "::set-env name=AWS_FRONTEND_BUCKET_ID_NAME::AWS_FRONTEND_BUCKET_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"

      - name: Configure AWS creds
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets[env.AWS_ACCESS_KEY_ID_SECRET_NAME] }}
          aws-secret-access-key: ${{ secrets[env.AWS_SECRET_ACCESS_KEY_SECRET_NAME] }}
          aws-region: us-east-1

      - name: Load backend secrets from SecretsManager
        id: load-backend-secrets
        run: |
          aws secretsmanager get-secret-value --secret-id ${{ needs.setup-env.outputs.deploy_env }}/backend > secrets.json
          jq -r .SecretString < secrets.json | \
            jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' > .env
          rm -f secrets.json
          kubectl create secret generic backend \
            --from-env-file=./.env \
            --dry-run=client \
            -o yaml > kubernetes/backend/templates/secret.yaml

      - name: Helm lint
        id: helm-lint
        run: |
          helm lint \
            -f kubernetes/backend/values/${{ needs.setup-env.outputs.deploy_env }}.yaml \
            kubernetes/backend

      - name: Helm template
        id: helm-template
        run: |
          helm template \
            --debug \
            -n ${{ needs.setup-env.outputs.deploy_env }}-backend \
            -f kubernetes/backend/values/${{ needs.setup-env.outputs.deploy_env }}.yaml \
            --set image.repository=${{ steps.login-ecr.outputs.registry }}/${{ needs.setup-env.outputs.deploy_env }}-backend \
            --set image.tag=${{ needs.setup-env.outputs.sha_short }} \
            --set s3.imagesBucket=devvesg-images-${{ needs.setup-env.outputs.deploy_env }} \
            kubernetes/backend > /dev/null

  build-and-test:
    name: Build and test
    runs-on: ubuntu-20.04

    needs:
      - setup-env

    steps:
      - uses: actions/checkout@v2
        id: checkout

      - name: Setup Node.js
        id: setup-node
        uses: actions/setup-node@v3
        with:
          node-version: 16

      - name: set-aws-credentials
        id: set-aws-credentials
        env:
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
        run: |
          echo "::set-env name=AWS_ACCESS_KEY_ID_SECRET_NAME::AWS_DEPLOY_ACCESS_KEY_ID_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_SECRET_ACCESS_KEY_SECRET_NAME::AWS_DEPLOY_SECRET_ACCESS_KEY_${{ needs.setup-env.outputs.infra_env }}"

      - name: Configure AWS credentials
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets[env.AWS_ACCESS_KEY_ID_SECRET_NAME] }}
          aws-secret-access-key: ${{ secrets[env.AWS_SECRET_ACCESS_KEY_SECRET_NAME] }}
          aws-region: us-east-1

      - name: Load frontend secrets from SecretsManager
        id: load-frontend-secrets
        run: |
          aws secretsmanager get-secret-value --secret-id ${{ needs.setup-env.outputs.deploy_env }}/frontend > secrets.json
          jq -r .SecretString < secrets.json | \
            jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' > client/.env
          rm -f secrets.json

      - uses: actions/cache@v3
        id: yarn-cache
        with:
          path: |
            client/.yarn/cache
            client/node_modules
          key: ${{ runner.os }}-frontend-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-frontend-yarn-

      - name: Build frontend
        id: build-frontend
        env:
          NODE_ENV: ${{ needs.setup-env.outputs.deploy_env }}
          WEBAPP_BASE_URL: ${{ env.FRONTEND_ENDPOINT }}
          REACT_APP_BUILD_ID: ${{ needs.setup-env.outputs.sha_short }}
        run: |
          cd client/
          npm config set "@fortawesome:registry" "https://npm.fontawesome.com/" && \
              npm config set "//npm.fontawesome.com/:_authToken" "${{ secrets.FONT_AWESOME_TOKEN }}"
          yarn install
          yarn run build

      - name: Upload frontend artifact
        id: upload-frontend-artifact
        uses: actions/upload-artifact@v3
        with:
          name: frontend-build
          path: client/build/
          retention-days: 3

      - name: Test frontend
        id: test-frontend
        env:
          NODE_ENV: staging
          WEBAPP_BASE_URL: ${{ env.FRONTEND_ENDPOINT }}
          REACT_APP_BUILD_ID: ${{ needs.setup-env.outputs.sha_short }}
        run: |
          cd client/
          yarn run test

      - name: Configure artifact AWS creds
        id: configure-artifact-aws-credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_DEPLOY_ACCESS_KEY_ID_ARTIFACT }}
          aws-secret-access-key: ${{ secrets.AWS_DEPLOY_SECRET_ACCESS_KEY_ARTIFACT }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build backend
        id: build-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # allow the pull to fail and we'll just build without a cache
          docker pull $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:latest || true
          docker build \
            -t $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:latest \
            -t $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:${{ needs.setup-env.outputs.sha_short }} \
            .

      # ## TODO: fix me with service sidecars
      # - name: Test backend
      #   id: test-backend
      #   continue-on-error: true
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #   run: |
      #     docker run --rm \
      #       --name backend-test \
      #       --workdir /app \
      #       $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:${{ needs.setup-env.outputs.sha_short }} \
      #       yarn run test

      - name: Push containers
        id: docker-push
        if: ${{ needs.setup-env.outputs.do_deploy == 'true' }}
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          docker push $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:${{ needs.setup-env.outputs.sha_short }}
          docker push $ECR_REGISTRY/${{ needs.setup-env.outputs.deploy_env }}-backend:latest

  deploy-frontend:
    name: Deploy frontend
    runs-on: ubuntu-20.04

    needs:
      - setup-env
      - build-and-test
      - test-helm

    if: ${{ needs.setup-env.outputs.do_deploy == 'true' }}

    steps:
      - name: Download frontend-artifact
        id: download-frontend-artifact
        uses: actions/download-artifact@v2
        with:
          name: frontend-build

      - name: Setup stage environment variables
        id: setup-stage-env-vars
        env:
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
        run: |
          echo "::set-env name=AWS_ACCESS_KEY_ID_SECRET_NAME::AWS_DEPLOY_ACCESS_KEY_ID_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_SECRET_ACCESS_KEY_SECRET_NAME::AWS_DEPLOY_SECRET_ACCESS_KEY_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_CLOUDFRONT_DISTRIBUTION_ID_NAME::AWS_CLOUDFRONT_DISTRIBUTION_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"
          echo "::set-env name=AWS_FRONTEND_BUCKET_ID_NAME::AWS_FRONTEND_BUCKET_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"

      - name: Configure AWS creds
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets[env.AWS_ACCESS_KEY_ID_SECRET_NAME] }}
          aws-secret-access-key: ${{ secrets[env.AWS_SECRET_ACCESS_KEY_SECRET_NAME] }}
          aws-region: us-east-1

      - name: Deploy to S3 bucket without deleting
        id: initial-s3-sync
        run: aws s3 sync --acl=public-read . s3://${{ secrets[env.AWS_FRONTEND_BUCKET_ID_NAME] }}/

      - name: Invalidate Cloudfront cache
        id: invalidate-cloudfront-cache
        run: |
          invalidation_id=$( aws cloudfront create-invalidation --distribution-id ${{ secrets[env.AWS_CLOUDFRONT_DISTRIBUTION_ID_NAME] }} --paths "/*" | jq -r .Invalidation.Id )
          echo "Invalidation ID = ${invalidation_id}"

          is_done=false
          count=0
          while [ ${is_done} != "true" ]; do
            sleep 10;
            status=$( aws cloudfront get-invalidation --distribution-id ${{ secrets[env.AWS_CLOUDFRONT_DISTRIBUTION_ID_NAME] }} --id ${invalidation_id} | jq -r .Invalidation.Status )
            count=$((count+1))

            echo "`date`: Invalidation is ${status}"

            if [ "${status}" == "Completed" -o ${count} -gt 15 ]; then
              is_done=true
            fi
          done

      - name: Deploy to S3 bucket and clean old versions
        id: final-s3-sync
        run: aws s3 sync --acl=public-read --delete . s3://${{ secrets[env.AWS_FRONTEND_BUCKET_ID_NAME] }}/

  deploy-backend:
    name: Deploy backend
    runs-on: ubuntu-20.04

    needs:
      - setup-env
      - build-and-test
      - test-helm

    if: ${{ needs.setup-env.outputs.do_deploy == 'true' }}

    steps:
      - name: Setup kubectl
        id: setup-kubectl
        run: |
          mkdir -m 0700 -p ${HOME}/.local/bin

          curl -o ${HOME}/.local/bin/kubectl https://s3.us-west-2.amazonaws.com/amazon-eks/1.20.4/2021-04-12/bin/linux/amd64/kubectl
          chmod u+x ${HOME}/.local/bin/kubectl

          echo "PATH=${HOME}/.local/bin:${PATH}" >> ${GITHUB_ENV}

      - name: Setup stage environment variables
        id: setup-stage-env-vars
        env:
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true
        run: |
          echo "::set-env name=AWS_ACCESS_KEY_ID_SECRET_NAME::AWS_DEPLOY_ACCESS_KEY_ID_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_SECRET_ACCESS_KEY_SECRET_NAME::AWS_DEPLOY_SECRET_ACCESS_KEY_${{ needs.setup-env.outputs.infra_env }}"
          echo "::set-env name=AWS_CLOUDFRONT_DISTRIBUTION_ID_NAME::AWS_CLOUDFRONT_DISTRIBUTION_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"
          echo "::set-env name=AWS_FRONTEND_BUCKET_ID_NAME::AWS_FRONTEND_BUCKET_ID_${{ needs.setup-env.outputs.infra_env }}_${{ needs.setup-env.outputs.deploy_env }}"

      - name: Configure AWS creds
        id: configure-aws-credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets[env.AWS_ACCESS_KEY_ID_SECRET_NAME] }}
          aws-secret-access-key: ${{ secrets[env.AWS_SECRET_ACCESS_KEY_SECRET_NAME] }}
          aws-region: us-east-1

      - uses: actions/checkout@v2
        id: checkout

      - name: Update kubeconfig
        id: update-kubeconfig
        run: |
          cluster_name=$( aws eks list-clusters | jq -r .clusters[0] )
          aws eks update-kubeconfig \
            --alias devvesg-${{ needs.setup-env.outputs.deploy_env }} \
            --name ${cluster_name}

      - name: Load backend secrets from SecretsManager
        id: load-backend-secrets
        run: |
          aws secretsmanager get-secret-value --secret-id ${{ needs.setup-env.outputs.deploy_env }}/backend > secrets.json
          jq -r .SecretString < secrets.json | \
            jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' > .env
          rm -f secrets.json
          kubectl create secret generic backend \
            --from-env-file=./.env \
            --dry-run=client \
            -o yaml > kubernetes/backend/templates/secret.yaml

      - name: Helm deploy
        id: helm-deploy
        run: |
          helm upgrade \
            --install \
            --timeout 15m0s \
            --wait \
            --debug \
            --atomic \
            -n ${{ needs.setup-env.outputs.deploy_env }}-backend \
            -f ./kubernetes/backend/values/${{ needs.setup-env.outputs.deploy_env }}.yaml \
            --set image.repository=189354048363.dkr.ecr.us-east-1.amazonaws.com/${{ needs.setup-env.outputs.deploy_env }}-backend \
            --set image.tag=${{ needs.setup-env.outputs.sha_short }} \
            --set s3.imagesBucket=devvesg-images-${{ needs.setup-env.outputs.deploy_env }} \
            backend \
            ./kubernetes/backend
